<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>注意力机制与transformer</title>
    <link href="/2026/01/23/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6%E4%B8%8Etransformer/"/>
    <url>/2026/01/23/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6%E4%B8%8Etransformer/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Transformer</tag>
      
      <tag>注意力</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最近的一些安排以及技术路线考虑</title>
    <link href="/2026/01/19/%E6%9C%80%E8%BF%91%E7%9A%84%E4%B8%80%E4%BA%9B%E5%AE%89%E6%8E%92%E4%BB%A5%E5%8F%8A%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF%E8%80%83%E8%99%91/"/>
    <url>/2026/01/19/%E6%9C%80%E8%BF%91%E7%9A%84%E4%B8%80%E4%BA%9B%E5%AE%89%E6%8E%92%E4%BB%A5%E5%8F%8A%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF%E8%80%83%E8%99%91/</url>
    
    <content type="html"><![CDATA[<h5 id="周内安排"><a href="#周内安排" class="headerlink" title="周内安排"></a>周内安排</h5><p>上周仔细看了一遍师兄的实验设计，这周要把不懂的地方给学一下，主要包括ResNet，感受野，MLP，知识图谱，知识推理等等相关知识概念，最重要的是要能够<strong>复现</strong>一下他的实验。</p><h5 id="技术路线考虑"><a href="#技术路线考虑" class="headerlink" title="技术路线考虑"></a>技术路线考虑</h5><p><strong>cs50</strong>目前是跳着看的，毕竟不是0基础，后续会在博客上写一些内容。</p><p>上周在此之外还给企业导师发了简历，但是<strong>并没有得到任何回应</strong>，我看了下时间，我现在最想知道的是研二什么时候会回学校，如果恰好一年的话，那也就是9月份直面秋招了，即使是六七月份回学校，给的时间其实也是紧张的。</p><p>我不清楚公司的业务如何，如果有互联网企业的可能，考虑技术积累的话，那么技术积累期也只有这么几个月了，从现在到9月份？</p><p>目前我看好的是<strong>大模型应用开发，以及java后端的一套技术栈</strong>，这段时间先做大模型的RAG开发项目，再学一点java，正好教研室的任务不是很紧急，应该能学一些，到时候可以试着更新一些内容。</p>]]></content>
    
    
    <categories>
      
      <category>闲思</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随想</tag>
      
      <tag>近期计划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于RAG技术的群聊回答网站or机器人的构想</title>
    <link href="/2026/01/16/%E5%9F%BA%E4%BA%8ERAG%E6%8A%80%E6%9C%AF%E7%9A%84%E7%BE%A4%E8%81%8A%E5%9B%9E%E7%AD%94%E7%BD%91%E7%AB%99or%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E6%9E%84%E6%83%B3/"/>
    <url>/2026/01/16/%E5%9F%BA%E4%BA%8ERAG%E6%8A%80%E6%9C%AF%E7%9A%84%E7%BE%A4%E8%81%8A%E5%9B%9E%E7%AD%94%E7%BD%91%E7%AB%99or%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E6%9E%84%E6%83%B3/</url>
    
    <content type="html"><![CDATA[<p>这个计划将以<strong>周</strong>为单位，每一步都有明确的产出和目标。你的唯一任务就是<strong>不惜一切代价（All in）</strong>，完成每周的目标。</p><hr><h3 id="Part-1-技术路线-Technology-Stack"><a href="#Part-1-技术路线-Technology-Stack" class="headerlink" title="Part 1: 技术路线 (Technology Stack)"></a>Part 1: 技术路线 (Technology Stack)</h3><p>这是你的核武器库。我们选择的都是最轻量、最高效、最适合该场景的工具。</p><div class="table-container"><table><thead><tr><th style="text-align:left">类别</th><th style="text-align:left">技术选型</th><th style="text-align:left">作用与原因</th></tr></thead><tbody><tr><td style="text-align:left"><strong>核心框架</strong></td><td style="text-align:left"><strong>LangChain</strong></td><td style="text-align:left">任务胶水。用于编排RAG的整个流程（加载、分割、嵌入、检索、生成），让你不用重复造轮子。</td></tr><tr><td style="text-align:left"><strong>API框架</strong></td><td style="text-align:left"><strong>FastAPI</strong></td><td style="text-align:left">你的AI大脑的“插座”。超高性能，极易上手，自带交互式API文档(Swagger UI)，比Django轻一百倍，是这个场景的最佳选择。</td></tr><tr><td style="text-align:left"><strong>QQ机器人</strong></td><td style="text-align:left"><strong>NoneBot2 + go-cqhttp</strong></td><td style="text-align:left">Python生态中最主流、最稳定的QQ机器人解决方案。</td></tr><tr><td style="text-align:left"><strong>向量数据库</strong></td><td style="text-align:left"><strong>ChromaDB</strong></td><td style="text-align:left">本地化、无需配置、内存/文件模式运行。让你能瞬间把向量存储跑起来，专注于RAG逻辑本身。</td></tr><tr><td style="text-align:left"><strong>Embedding模型</strong></td><td style="text-align:left"><strong>Sentence-Transformers</strong></td><td style="text-align:left">开源、本地运行。不依赖任何API，速度快，效果好，完全免费，是原型开发和学习的不二之选。</td></tr><tr><td style="text-align:left"><strong>大语言模型(LLM)</strong></td><td style="text-align:left"><strong>Kimi (Moonshot) / DeepSeek API</strong></td><td style="text-align:left">国内厂商提供，有免费额度，API兼容OpenAI格式，对中文支持极好，是学生开发者的福音。</td></tr><tr><td style="text-align:left"><strong>HTTP客户端</strong></td><td style="text-align:left"><strong>HTTPX</strong></td><td style="text-align:left"><code>requests</code>的现代替代品，支持异步请求，与FastAPI完美配合。</td></tr></tbody></table></div><hr><h3 id="Part-2-环境配置-Environment-Setup"><a href="#Part-2-环境配置-Environment-Setup" class="headerlink" title="Part 2: 环境配置 (Environment Setup)"></a>Part 2: 环境配置 (Environment Setup)</h3><p>环境配不好，一天就白费。严格按照以下步骤，一次性搞定。</p><ol><li><p><strong>基础软件</strong>:</p><ul><li><strong>Python (3.9+)</strong>: 确保你的Python版本正确。</li><li><strong>Git</strong>: 用于版本控制。</li></ul></li><li><p><strong>创建项目文件夹</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> qq-rag-bot<br><span class="hljs-built_in">cd</span> qq-rag-bot<br>git init<br></code></pre></td></tr></table></figure></li><li><p><strong>创建并激活Python虚拟环境 (至关重要！)</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Windows</span><br>python -m venv venv<br>.\venv\Scripts\activate<br><br><span class="hljs-comment"># macOS / Linux</span><br>python3 -m venv venv<br><span class="hljs-built_in">source</span> venv/bin/activate<br></code></pre></td></tr></table></figure><p><em>看到命令行前面有 <code>(venv)</code> 字样，代表成功。</em></p></li><li><p><strong>安装所有Python依赖</strong>:</p><ul><li>一次性把所有需要的库装好。创建一个 <code>requirements.txt</code> 文件，写入以下内容：</li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs txt"># requirements.txt<br><br># RAG Core<br>langchain<br>chromadb<br>sentence-transformers<br><br># LLM &amp; API<br>openai # Kimi和DeepSeek的SDK与OpenAI兼容<br>fastapi<br>uvicorn[standard] # 运行FastAPI的服务<br>httpx<br>python-dotenv<br><br># QQ Bot<br>nonebot2<br>nonebot-adapter-onebot<br></code></pre></td></tr></table></figure><ul><li>然后在命令行中执行安装：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install -r requirements.txt<br></code></pre></td></tr></table></figure></li><li><p><strong>获取API Key</strong>:</p><ul><li>去Kimi或DeepSeek的开放平台注册，获取你的API Key。</li><li>在项目根目录创建一个 <code>.env</code> 文件（注意前面有个点），用于存放密钥，<strong>千万不要把Key直接写在代码里！</strong></li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># .env 文件内容</span><br><span class="hljs-attr">API_KEY</span>=<span class="hljs-string">&quot;sk-xxxxxxxxxxxxxxxxxxxxxxxx&quot;</span><br><span class="hljs-attr">BASE_URL</span>=<span class="hljs-string">&quot;https://api.moonshot.cn/v1&quot;</span> <span class="hljs-comment"># 这是Kimi的地址，DeepSeek有自己的地址</span><br></code></pre></td></tr></table></figure></li><li><p><strong>下载并配置 <code>go-cqhttp</code></strong>:</p><ul><li>这是一个独立的程序，不是Python库。去它的 <a href="https://github.com/Mrs4s/go-cqhttp/releases">GitHub Release</a> 页面下载适合你操作系统的版本。</li><li>第一次运行它会让你选择通信方式，选择 <code>0: 反向 WebSocket 通信</code>。然后它会生成一个配置文件，你需要登录你的机器人QQ号，并根据<code>nonebot2</code>的要求配置好反向WS的地址。</li></ul></li></ol><hr><h3 id="Part-3-极限冲刺实现路径-Accelerated-Implementation-Path"><a href="#Part-3-极限冲刺实现路径-Accelerated-Implementation-Path" class="headerlink" title="Part 3: 极限冲刺实现路径 (Accelerated Implementation Path)"></a>Part 3: 极限冲刺实现路径 (Accelerated Implementation Path)</h3><p><strong>总目标：4周内，让机器人在群里回答第一个问题。</strong></p><h4 id="Week-1-本地验证-RAG核心逻辑贯通"><a href="#Week-1-本地验证-RAG核心逻辑贯通" class="headerlink" title="Week 1: 本地验证 - RAG核心逻辑贯通"></a><strong>Week 1: 本地验证 - RAG核心逻辑贯通</strong></h4><p><strong>目标：写出一个能在命令行里运行的问答脚本 <code>rag_script.py</code>。</strong></p><ul><li><p><strong>Day 1-2: 数据准备与加载。</strong></p><ol><li>创建 <code>knowledge_base.md</code> 文件，手动录入10-20条高质量的Q&amp;A。</li><li>学习 <code>LangChain</code> 的 <code>TextLoader</code> 和 <code>RecursiveCharacterTextSplitter</code>。</li><li>写代码，成功加载<code>knowledge_base.md</code>并将其分割成文本块(chunks)。</li></ol></li><li><p><strong>Day 3-4: 向量化与存储。</strong></p><ol><li>学习 <code>Sentence-Transformers</code> 和 <code>ChromaDB</code>。</li><li>在脚本中集成代码：初始化Embedding模型，将分割好的文本块向量化，存入本地的ChromaDB数据库中。</li></ol></li><li><p><strong>Day 5-7: 检索、生成与测试。</strong></p><ol><li>学习 <code>LangChain</code> 的 <code>ChatPromptTemplate</code> 和 <code>LLMChain</code>。</li><li>在脚本中实现：输入一个问题 -&gt; 向量化问题 -&gt; 从ChromaDB中检索最相关的3个文本块 -&gt; 将文本块和问题组合成一个Prompt -&gt; 调用LLM API获取答案 -&gt; 在命令行打印。</li><li><strong>疯狂测试</strong>，调整Prompt，直到回答效果基本满意。</li></ol></li><li><p><strong>本周产出</strong>: 一个能独立运行的<code>rag_script.py</code>，证明你的RAG链路是通的。</p></li></ul><h4 id="Week-2-服务封装-将大脑装进“铁盒”"><a href="#Week-2-服务封装-将大脑装进“铁盒”" class="headerlink" title="Week 2: 服务封装 - 将大脑装进“铁盒”"></a><strong>Week 2: 服务封装 - 将大脑装进“铁盒”</strong></h4><p><strong>目标：用FastAPI把RAG能力封装成一个任何人都能调用的API。</strong></p><ul><li><p><strong>Day 1-2: FastAPI入门。</strong></p><ol><li>学习FastAPI的<code>@app.post()</code>装饰器，<code>pydantic</code>数据模型。</li><li>写一个<code>main.py</code>，创建一个 <code>/hello</code> 接口，返回 “world”。用<code>uvicorn main:app --reload</code>把它跑起来。</li></ol></li><li><p><strong>Day 3-5: RAG逻辑API化。</strong></p><ol><li>将Week 1的RAG脚本代码重构成一个函数，例如 <code>get_rag_answer(query: str) -&gt; str</code>。</li><li>在<code>main.py</code>中，创建一个 <code>/api/chat</code> 的POST接口。</li><li>这个接口接收一个包含问题的JSON，调用<code>get_rag_answer</code>函数，然后将结果以JSON格式返回。</li></ol></li><li><p><strong>Day 6-7: 测试与文档。</strong></p><ol><li>启动FastAPI服务，浏览器访问 <code>http://127.0.0.1:8000/docs</code>。</li><li>你将看到一个自动生成的、漂亮的、可交互的API文档页面。</li><li>在这个页面上反复测试你的API，确保它工作正常。</li></ol></li><li><p><strong>本周产出</strong>: 一个健壮的、有文档的、随时待命的AI问答后端服务。</p></li></ul><h4 id="Week-3-应用接入-给“大脑”插上“嘴巴”"><a href="#Week-3-应用接入-给“大脑”插上“嘴巴”" class="headerlink" title="Week 3: 应用接入 - 给“大脑”插上“嘴巴”"></a><strong>Week 3: 应用接入 - 给“大脑”插上“嘴巴”</strong></h4><p><strong>目标：让QQ机器人跑起来，并能与你的API服务对话。</strong></p><ul><li><p><strong>Day 1-3: NoneBot2与go-cqhttp联调。</strong></p><ol><li>这是最可能遇到配置问题的地方，保持耐心。</li><li>严格按照<code>nonebot2</code>的官方文档初始化项目。</li><li>配置<code>go-cqhttp</code>，使其能连接到<code>nonebot2</code>。</li><li>成功登录机器人QQ号，并在群里发一句 “Hello, world!”。</li></ol></li><li><p><strong>Day 4-7: 编写机器人插件。</strong></p><ol><li>学习<code>nonebot2</code>的事件响应器和消息匹配器。</li><li>编写一个插件，逻辑如下：<ul><li>当有人@机器人时，触发响应。</li><li>获取@消息中去掉@部分的核心问题文本。</li><li>使用<code>httpx</code>库，<strong>异步地</strong>调用你Week 2搭建的FastAPI接口 (<code>http://127.0.0.1:8000/api/chat</code>)。</li><li>获取API返回的答案。</li><li>在群里@提问者并回复答案。</li></ul></li></ol></li><li><p><strong>本周产出</strong>: 一个能在群里接收问题、调用API、并回复答案的QQ机器人原型。</p></li></ul><h4 id="Week-4-优化迭代-从“能用”到“好用”"><a href="#Week-4-优化迭代-从“能用”到“好用”" class="headerlink" title="Week 4: 优化迭代 - 从“能用”到“好用”"></a><strong>Week 4: 优化迭代 - 从“能用”到“好用”</strong></h4><p><strong>目标：修复问题，增加必要功能，让项目更完善。</strong></p><ul><li><strong>错误处理</strong>: 如果API挂了或LLM没返回，机器人应该回复友好的提示，而不是崩溃。</li><li><strong>异步优化</strong>: 确保机器人调用API是异步的，防止因为等待API响应而卡住整个机器人。</li><li><strong>知识库更新</strong>: 思考如何更方便地更新你的<code>knowledge_base.md</code>文件。可以写一个简单的API来加载新知识。</li><li><strong>Prompt调优</strong>: 根据实际使用情况，不断优化你的Prompt模板，让回答更精准。</li><li><strong>整理GitHub仓库</strong>: 写一个清晰的<code>README.md</code>，描述你的项目、如何配置、如何运行。这是你未来求职的门面！</li></ul><p>这个计划强度极大，但每一步都踩在关键点上。<strong>立刻开始，不要犹豫，严格执行。</strong>遇到问题时，记住你的目标，利用好搜索引擎和官方文档。四周后，你将拥有一个能彻底改变你简历分量的杀手级项目。</p>]]></content>
    
    
    <categories>
      
      <category>大模型应用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大模型</tag>
      
      <tag>RAG</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通过Github仓库异地同步、更新博客文章的方法</title>
    <link href="/2026/01/07/%E9%80%9A%E8%BF%87Github%E4%BB%93%E5%BA%93%E5%BC%82%E5%9C%B0%E5%90%8C%E6%AD%A5%E3%80%81%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <url>/2026/01/07/%E9%80%9A%E8%BF%87Github%E4%BB%93%E5%BA%93%E5%BC%82%E5%9C%B0%E5%90%8C%E6%AD%A5%E3%80%81%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h4 id=""><a href="#" class="headerlink" title=" "></a> </h4><p>考虑到可能在教研室、宿舍、教室等不同的地方更新博客，就添加了一个github仓库来存储博客的文章内容，这样的话就能够通过这个仓库在不同的工作站上实现同步。思路大致如下：</p><p>由于本站使用hexo建站，实现逻辑是这样的</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">本地Markdown文章 → Hexo生成静态<span class="hljs-selector-tag">HTML</span> → 推送到GitHub Pages → 用户访问<br></code></pre></td></tr></table></figure><p>hexo文档只要绑定到本站对应的page，那么理论在哪里都可以完成Hexo生成静态HTML之后的部分。</p><p>所以想要异地完成的话，其实很简单，只需要同步文件就可以了，这里我通过创建一个github仓库，先通过pull把他们都下载到本地，然后当我更新的时候，把新的markdown文章在push到这个仓库里。</p><p>就能够实现同步了，本质就是把存储这部分放在了github上。</p><p>在任何一个设备上，我想要发一个文章的话，只需要配置基本的git和hexo环境，然后按照下面的流程来就可以：</p><h5 id="1-先同步源码"><a href="#1-先同步源码" class="headerlink" title="1.先同步源码"></a>1.先同步源码</h5><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git pull</span><br></code></pre></td></tr></table></figure><h5 id="2-新建文章"><a href="#2-新建文章" class="headerlink" title="2.新建文章"></a>2.新建文章</h5><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">hexo <span class="hljs-built_in">new</span> <span class="hljs-built_in">post</span> <span class="hljs-string">&quot;文章标题&quot;</span><br></code></pre></td></tr></table></figure><h5 id="3-本地测试"><a href="#3-本地测试" class="headerlink" title="3.本地测试"></a>3.本地测试</h5><figure class="highlight plaintext"><figcaption><span>clean</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs hexo">hexo g<br>hexo s<br></code></pre></td></tr></table></figure><p><code>浏览器打开 http://localhost:4000</code></p><h5 id="4-提交到Github仓库"><a href="#4-提交到Github仓库" class="headerlink" title="4.提交到Github仓库"></a>4.提交到Github仓库</h5><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">git <span class="hljs-keyword">add</span> .<br>git commit -m <span class="hljs-string">&quot;Add post: 文章标题&quot;</span><br>git <span class="hljs-keyword">push</span><br></code></pre></td></tr></table></figure><h5 id="5-在线发布文章"><a href="#5-在线发布文章" class="headerlink" title="5.在线发布文章"></a>5.在线发布文章</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">hexo clean<br>hexo <span class="hljs-selector-tag">g</span><br>hexo d<br></code></pre></td></tr></table></figure><p>​    这种方法的缺点也很明显，所有的文章都是开源的，而且在云端存储，长期积累，仓库体积会越来越大，特别是包含图片时。</p><p>​    后续会考虑一些更加合适的方法</p>]]></content>
    
    
    <categories>
      
      <category>博客相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>同步</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>知识图谱基本概念</title>
    <link href="/2025/10/23/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E6%A6%82%E5%BF%B5/"/>
    <url>/2025/10/23/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h4 id="知识图谱"><a href="#知识图谱" class="headerlink" title="知识图谱"></a>知识图谱</h4><h5 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h5><p>通过实体和关系的三元组，将知识以结构化的方式表示</p><p>三元组例：（丁真）——(故乡)——&gt;（理塘），三元组表示这样的一个关系</p><h5 id="构建方法"><a href="#构建方法" class="headerlink" title="构建方法"></a>构建方法</h5><p>1.收集各种数据，包括但不限于文档，网页，图片等等</p><p>2.数据清洗，除去原始数据中的错误，将数据规范化等待</p><p>3.信息抽取，从非结构化文本中提取实体和关系，形成三元组。</p><p>4.知识融合，将不同来源的相同实体进行对齐和合并（例如消除同名异义、异名同义）。</p><p>5.存储，一般通过图数据库来表示，因为是典型的图结构，常见的有Neo4j，ArangoDB等等</p><h5 id="应用范围"><a href="#应用范围" class="headerlink" title="应用范围"></a>应用范围</h5><p>针对专用领域，进行知识问答，知识可视化，以及推荐。</p><h4 id="知识推理"><a href="#知识推理" class="headerlink" title="知识推理"></a>知识推理</h4><p>就是利用图谱中已有的数据，去发现新的关系或补全缺失的信息，主要分为<strong>补全</strong>和<strong>纠错</strong>两大功能</p><h5 id="补全"><a href="#补全" class="headerlink" title="补全"></a>补全</h5><p>图谱里有断开的连接，通过推理把他们连起来</p><h5 id="纠错"><a href="#纠错" class="headerlink" title="纠错"></a>纠错</h5><p>检测图谱里是否有矛盾？</p>]]></content>
    
    
    
    <tags>
      
      <tag>图神经网络</tag>
      
      <tag>知识图谱</tag>
      
      <tag>知识推理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>教研室测试</title>
    <link href="/2024/11/10/%E8%BF%9C%E7%A8%8B%E6%B5%8B%E8%AF%95/"/>
    <url>/2024/11/10/%E8%BF%9C%E7%A8%8B%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<p>这是我在 <strong>教研室电脑</strong> 写的第一篇测试博客。</p><ul><li>环境：新电脑</li><li>方式：git + hexo</li><li>目标：多地点无缝写博客</li></ul><p>如果能看到这篇文章，说明这条链路是通的 </p>]]></content>
    
    
    <categories>
      
      <category>日志</category>
      
    </categories>
    
    
    <tags>
      
      <tag>教研室</tag>
      
      <tag>测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深度学习基础知识P1</title>
    <link href="/2024/01/20/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86P1/"/>
    <url>/2024/01/20/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86P1/</url>
    
    <content type="html"><![CDATA[<p>这里主要介绍一些深度学习的基本概念</p><h5 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h5><p>一种用于通过卷积提取数据特征的神经网络</p><h5 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h5><p>通过一个卷积核在图像/矩阵上的滑动，计算出窗口元素与卷积核对应元素的乘积之和，并得到一个新的矩阵</p><h5 id="padding（填充）"><a href="#padding（填充）" class="headerlink" title="padding（填充）"></a>padding（填充）</h5><p>在输入的边界周围<strong>填充额外的行列（通常为0）</strong>，<strong>防止卷积后图像快速变小</strong>，也能够<strong>确保边界处能够进行完整的卷积操作</strong></p><h5 id="stride（步长）"><a href="#stride（步长）" class="headerlink" title="stride（步长）"></a>stride（步长）</h5><p>卷积核在输入上滑动的幅度大小</p><p>上述各参数直接有这样的关系，设输入的数据尺寸为$\text{Input_Size}$，卷积核尺寸为$\text{Kernel_Size}$，Padding层数为$P$，步长为$S$，输出的数据尺寸为$\text{Output_Size}$，那么有如下公式</p><p>\[<br>\text{Output_Size} = \frac{(\text{Input_Size} - \text{Kernel_Size} + 2 \times P)}{S} + 1<br>\]</p><h5 id="Pooling（池化）"><a href="#Pooling（池化）" class="headerlink" title="Pooling（池化）"></a>Pooling（池化）</h5><p>本质是进行下采样，减小数据的尺寸，以常见的最大池化为例，选用最大的值，来代表被池化的整个区域块的值。例如2×2池化后，这四个数据选取最大的值保留，作为池化结果。</p><p>池化也可以采用步长，但是考虑到降采样的功能，一般不会像卷积一样重叠，常用的有2×2池化，步长为2</p><h5 id="感受野-Receptive-Field"><a href="#感受野-Receptive-Field" class="headerlink" title="感受野-Receptive Field"></a>感受野-Receptive Field</h5><p>经过网络输出的一个点，对应原图的数据范围，也就是这个点“感受”到了原图的区域范围，如图所示。</p><p>池化（Pooling）可以快速的增加神经元对应的感受野</p><p>实际有效的感受野（Effective Receptive Field）一般比数值上的感受野要小，因为经过训练，往往会呈现中心更强，边缘更弱的分布。</p><img src="/2024/01/20/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86P1/reception-field.png" class="" title="感受野示意图"><h5 id="MLP"><a href="#MLP" class="headerlink" title="MLP"></a>MLP</h5><p>由<strong>输入层、隐藏层、输出层</strong>构成的网络，这里的隐藏层指的是除了输入&amp;输出之外的其他中间层（隐藏层中通常使用非线性激活函数，比如<strong>ReLU</strong>），可以是很多层，MLP通常用来构建<strong>分类头</strong>，<strong>投影头</strong>以及<strong>GNN的特征变换</strong>。下面是一个图例</p><img src="/2024/01/20/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86P1/mlp-structure.png" class="" title="MLP示意图"><h5 id="发展脉络"><a href="#发展脉络" class="headerlink" title="发展脉络"></a>发展脉络</h5><h6 id="LeNet-5"><a href="#LeNet-5" class="headerlink" title="LeNet-5"></a>LeNet-5</h6><p> 第一款实际应用的神经网络，奠定了基础架构——<strong>卷积，池化，全连接</strong></p><img src="/2024/01/20/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86P1/lenet5.png" class="" title="LeNet5"><h6 id="AlexNet"><a href="#AlexNet" class="headerlink" title="AlexNet"></a>AlexNet</h6><p>融入了ReLU激活函数，增加dropout减轻过拟合，并<strong>在GPU上成功训练</strong></p><img src="/2024/01/20/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86P1/alexnet.png" class="" title="AlexNet"><h6 id="VGG"><a href="#VGG" class="headerlink" title="VGG"></a>VGG</h6><p>提出网络深度至关重要，用<strong>小卷积核构建更深的网络</strong></p><h6 id="GoogleNet"><a href="#GoogleNet" class="headerlink" title="GoogleNet"></a>GoogleNet</h6><p>在“宽度”上处理，在<strong>同一层同时使用不同大小的卷积</strong>核捕捉不同尺度的特征</p><h6 id="ResNet"><a href="#ResNet" class="headerlink" title="ResNet"></a>ResNet</h6><p>引入<strong>残差连接</strong>，梯度可以直接回传，防止网络退化，可以让网络更深</p><img src="/2024/01/20/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86P1/evolution-path.png" class="" title="evolution path">]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度学习</tag>
      
      <tag>基础知识</tag>
      
      <tag>卷积神经网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>测试</title>
    <link href="/2023/12/05/%E6%B5%8B%E8%AF%95/"/>
    <url>/2023/12/05/%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<p>这是我课程设计的一个项目，现在整理一下到博客上。</p><ul><li>技术栈：Python, PyTorch</li><li>主要工作：模型训练 + 实验记录</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/10/09/hello-world/"/>
    <url>/2023/10/09/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
