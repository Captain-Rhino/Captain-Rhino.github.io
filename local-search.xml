<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>基于RAG技术的群聊回答网站or机器人的构想</title>
    <link href="/2026/01/16/%E5%9F%BA%E4%BA%8ERAG%E6%8A%80%E6%9C%AF%E7%9A%84%E7%BE%A4%E8%81%8A%E5%9B%9E%E7%AD%94%E7%BD%91%E7%AB%99or%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E6%9E%84%E6%83%B3/"/>
    <url>/2026/01/16/%E5%9F%BA%E4%BA%8ERAG%E6%8A%80%E6%9C%AF%E7%9A%84%E7%BE%A4%E8%81%8A%E5%9B%9E%E7%AD%94%E7%BD%91%E7%AB%99or%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E6%9E%84%E6%83%B3/</url>
    
    <content type="html"><![CDATA[<p>这个计划将以<strong>周</strong>为单位，每一步都有明确的产出和目标。你的唯一任务就是<strong>不惜一切代价（All in）</strong>，完成每周的目标。</p><hr><h3 id="Part-1-技术路线-Technology-Stack"><a href="#Part-1-技术路线-Technology-Stack" class="headerlink" title="Part 1: 技术路线 (Technology Stack)"></a>Part 1: 技术路线 (Technology Stack)</h3><p>这是你的核武器库。我们选择的都是最轻量、最高效、最适合该场景的工具。</p><table><thead><tr><th align="left">类别</th><th align="left">技术选型</th><th align="left">作用与原因</th></tr></thead><tbody><tr><td align="left"><strong>核心框架</strong></td><td align="left"><strong>LangChain</strong></td><td align="left">任务胶水。用于编排RAG的整个流程（加载、分割、嵌入、检索、生成），让你不用重复造轮子。</td></tr><tr><td align="left"><strong>API框架</strong></td><td align="left"><strong>FastAPI</strong></td><td align="left">你的AI大脑的“插座”。超高性能，极易上手，自带交互式API文档(Swagger UI)，比Django轻一百倍，是这个场景的最佳选择。</td></tr><tr><td align="left"><strong>QQ机器人</strong></td><td align="left"><strong>NoneBot2 + go-cqhttp</strong></td><td align="left">Python生态中最主流、最稳定的QQ机器人解决方案。</td></tr><tr><td align="left"><strong>向量数据库</strong></td><td align="left"><strong>ChromaDB</strong></td><td align="left">本地化、无需配置、内存&#x2F;文件模式运行。让你能瞬间把向量存储跑起来，专注于RAG逻辑本身。</td></tr><tr><td align="left"><strong>Embedding模型</strong></td><td align="left"><strong>Sentence-Transformers</strong></td><td align="left">开源、本地运行。不依赖任何API，速度快，效果好，完全免费，是原型开发和学习的不二之选。</td></tr><tr><td align="left"><strong>大语言模型(LLM)</strong></td><td align="left"><strong>Kimi (Moonshot) &#x2F; DeepSeek API</strong></td><td align="left">国内厂商提供，有免费额度，API兼容OpenAI格式，对中文支持极好，是学生开发者的福音。</td></tr><tr><td align="left"><strong>HTTP客户端</strong></td><td align="left"><strong>HTTPX</strong></td><td align="left"><code>requests</code>的现代替代品，支持异步请求，与FastAPI完美配合。</td></tr></tbody></table><hr><h3 id="Part-2-环境配置-Environment-Setup"><a href="#Part-2-环境配置-Environment-Setup" class="headerlink" title="Part 2: 环境配置 (Environment Setup)"></a>Part 2: 环境配置 (Environment Setup)</h3><p>环境配不好，一天就白费。严格按照以下步骤，一次性搞定。</p><ol><li><p><strong>基础软件</strong>:</p><ul><li><strong>Python (3.9+)</strong>: 确保你的Python版本正确。</li><li><strong>Git</strong>: 用于版本控制。</li></ul></li><li><p><strong>创建项目文件夹</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> qq-rag-bot<br><span class="hljs-built_in">cd</span> qq-rag-bot<br>git init<br></code></pre></td></tr></table></figure></li><li><p><strong>创建并激活Python虚拟环境 (至关重要！)</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Windows</span><br>python -m venv venv<br>.\venv\Scripts\activate<br><br><span class="hljs-comment"># macOS / Linux</span><br>python3 -m venv venv<br><span class="hljs-built_in">source</span> venv/bin/activate<br></code></pre></td></tr></table></figure><p><em>看到命令行前面有 <code>(venv)</code> 字样，代表成功。</em></p></li><li><p><strong>安装所有Python依赖</strong>:</p><ul><li>一次性把所有需要的库装好。创建一个 <code>requirements.txt</code> 文件，写入以下内容：</li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs txt"># requirements.txt<br><br># RAG Core<br>langchain<br>chromadb<br>sentence-transformers<br><br># LLM &amp; API<br>openai # Kimi和DeepSeek的SDK与OpenAI兼容<br>fastapi<br>uvicorn[standard] # 运行FastAPI的服务<br>httpx<br>python-dotenv<br><br># QQ Bot<br>nonebot2<br>nonebot-adapter-onebot<br></code></pre></td></tr></table></figure><ul><li>然后在命令行中执行安装：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install -r requirements.txt<br></code></pre></td></tr></table></figure></li><li><p><strong>获取API Key</strong>:</p><ul><li>去Kimi或DeepSeek的开放平台注册，获取你的API Key。</li><li>在项目根目录创建一个 <code>.env</code> 文件（注意前面有个点），用于存放密钥，<strong>千万不要把Key直接写在代码里！</strong></li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># .env 文件内容</span><br><span class="hljs-attr">API_KEY</span>=<span class="hljs-string">&quot;sk-xxxxxxxxxxxxxxxxxxxxxxxx&quot;</span><br><span class="hljs-attr">BASE_URL</span>=<span class="hljs-string">&quot;https://api.moonshot.cn/v1&quot;</span> <span class="hljs-comment"># 这是Kimi的地址，DeepSeek有自己的地址</span><br></code></pre></td></tr></table></figure></li><li><p><strong>下载并配置 <code>go-cqhttp</code></strong>:</p><ul><li>这是一个独立的程序，不是Python库。去它的 <a href="https://github.com/Mrs4s/go-cqhttp/releases">GitHub Release</a> 页面下载适合你操作系统的版本。</li><li>第一次运行它会让你选择通信方式，选择 <code>0: 反向 WebSocket 通信</code>。然后它会生成一个配置文件，你需要登录你的机器人QQ号，并根据<code>nonebot2</code>的要求配置好反向WS的地址。</li></ul></li></ol><hr><h3 id="Part-3-极限冲刺实现路径-Accelerated-Implementation-Path"><a href="#Part-3-极限冲刺实现路径-Accelerated-Implementation-Path" class="headerlink" title="Part 3: 极限冲刺实现路径 (Accelerated Implementation Path)"></a>Part 3: 极限冲刺实现路径 (Accelerated Implementation Path)</h3><p><strong>总目标：4周内，让机器人在群里回答第一个问题。</strong></p><h4 id="Week-1-本地验证-RAG核心逻辑贯通"><a href="#Week-1-本地验证-RAG核心逻辑贯通" class="headerlink" title="Week 1: 本地验证 - RAG核心逻辑贯通"></a><strong>Week 1: 本地验证 - RAG核心逻辑贯通</strong></h4><p><strong>目标：写出一个能在命令行里运行的问答脚本 <code>rag_script.py</code>。</strong></p><ul><li><p><strong>Day 1-2: 数据准备与加载。</strong></p><ol><li>创建 <code>knowledge_base.md</code> 文件，手动录入10-20条高质量的Q&amp;A。</li><li>学习 <code>LangChain</code> 的 <code>TextLoader</code> 和 <code>RecursiveCharacterTextSplitter</code>。</li><li>写代码，成功加载<code>knowledge_base.md</code>并将其分割成文本块(chunks)。</li></ol></li><li><p><strong>Day 3-4: 向量化与存储。</strong></p><ol><li>学习 <code>Sentence-Transformers</code> 和 <code>ChromaDB</code>。</li><li>在脚本中集成代码：初始化Embedding模型，将分割好的文本块向量化，存入本地的ChromaDB数据库中。</li></ol></li><li><p><strong>Day 5-7: 检索、生成与测试。</strong></p><ol><li>学习 <code>LangChain</code> 的 <code>ChatPromptTemplate</code> 和 <code>LLMChain</code>。</li><li>在脚本中实现：输入一个问题 -&gt; 向量化问题 -&gt; 从ChromaDB中检索最相关的3个文本块 -&gt; 将文本块和问题组合成一个Prompt -&gt; 调用LLM API获取答案 -&gt; 在命令行打印。</li><li><strong>疯狂测试</strong>，调整Prompt，直到回答效果基本满意。</li></ol></li><li><p><strong>本周产出</strong>: 一个能独立运行的<code>rag_script.py</code>，证明你的RAG链路是通的。</p></li></ul><h4 id="Week-2-服务封装-将大脑装进“铁盒”"><a href="#Week-2-服务封装-将大脑装进“铁盒”" class="headerlink" title="Week 2: 服务封装 - 将大脑装进“铁盒”"></a><strong>Week 2: 服务封装 - 将大脑装进“铁盒”</strong></h4><p><strong>目标：用FastAPI把RAG能力封装成一个任何人都能调用的API。</strong></p><ul><li><p><strong>Day 1-2: FastAPI入门。</strong></p><ol><li>学习FastAPI的<code>@app.post()</code>装饰器，<code>pydantic</code>数据模型。</li><li>写一个<code>main.py</code>，创建一个 <code>/hello</code> 接口，返回 “world”。用<code>uvicorn main:app --reload</code>把它跑起来。</li></ol></li><li><p><strong>Day 3-5: RAG逻辑API化。</strong></p><ol><li>将Week 1的RAG脚本代码重构成一个函数，例如 <code>get_rag_answer(query: str) -&gt; str</code>。</li><li>在<code>main.py</code>中，创建一个 <code>/api/chat</code> 的POST接口。</li><li>这个接口接收一个包含问题的JSON，调用<code>get_rag_answer</code>函数，然后将结果以JSON格式返回。</li></ol></li><li><p><strong>Day 6-7: 测试与文档。</strong></p><ol><li>启动FastAPI服务，浏览器访问 <code>http://127.0.0.1:8000/docs</code>。</li><li>你将看到一个自动生成的、漂亮的、可交互的API文档页面。</li><li>在这个页面上反复测试你的API，确保它工作正常。</li></ol></li><li><p><strong>本周产出</strong>: 一个健壮的、有文档的、随时待命的AI问答后端服务。</p></li></ul><h4 id="Week-3-应用接入-给“大脑”插上“嘴巴”"><a href="#Week-3-应用接入-给“大脑”插上“嘴巴”" class="headerlink" title="Week 3: 应用接入 - 给“大脑”插上“嘴巴”"></a><strong>Week 3: 应用接入 - 给“大脑”插上“嘴巴”</strong></h4><p><strong>目标：让QQ机器人跑起来，并能与你的API服务对话。</strong></p><ul><li><p><strong>Day 1-3: NoneBot2与go-cqhttp联调。</strong></p><ol><li>这是最可能遇到配置问题的地方，保持耐心。</li><li>严格按照<code>nonebot2</code>的官方文档初始化项目。</li><li>配置<code>go-cqhttp</code>，使其能连接到<code>nonebot2</code>。</li><li>成功登录机器人QQ号，并在群里发一句 “Hello, world!”。</li></ol></li><li><p><strong>Day 4-7: 编写机器人插件。</strong></p><ol><li>学习<code>nonebot2</code>的事件响应器和消息匹配器。</li><li>编写一个插件，逻辑如下：<ul><li>当有人@机器人时，触发响应。</li><li>获取@消息中去掉@部分的核心问题文本。</li><li>使用<code>httpx</code>库，<strong>异步地</strong>调用你Week 2搭建的FastAPI接口 (<code>http://127.0.0.1:8000/api/chat</code>)。</li><li>获取API返回的答案。</li><li>在群里@提问者并回复答案。</li></ul></li></ol></li><li><p><strong>本周产出</strong>: 一个能在群里接收问题、调用API、并回复答案的QQ机器人原型。</p></li></ul><h4 id="Week-4-优化迭代-从“能用”到“好用”"><a href="#Week-4-优化迭代-从“能用”到“好用”" class="headerlink" title="Week 4: 优化迭代 - 从“能用”到“好用”"></a><strong>Week 4: 优化迭代 - 从“能用”到“好用”</strong></h4><p><strong>目标：修复问题，增加必要功能，让项目更完善。</strong></p><ul><li><strong>错误处理</strong>: 如果API挂了或LLM没返回，机器人应该回复友好的提示，而不是崩溃。</li><li><strong>异步优化</strong>: 确保机器人调用API是异步的，防止因为等待API响应而卡住整个机器人。</li><li><strong>知识库更新</strong>: 思考如何更方便地更新你的<code>knowledge_base.md</code>文件。可以写一个简单的API来加载新知识。</li><li><strong>Prompt调优</strong>: 根据实际使用情况，不断优化你的Prompt模板，让回答更精准。</li><li><strong>整理GitHub仓库</strong>: 写一个清晰的<code>README.md</code>，描述你的项目、如何配置、如何运行。这是你未来求职的门面！</li></ul><p>这个计划强度极大，但每一步都踩在关键点上。**立刻开始，不要犹豫，严格执行。**遇到问题时，记住你的目标，利用好搜索引擎和官方文档。四周后，你将拥有一个能彻底改变你简历分量的杀手级项目。</p>]]></content>
    
    
    <categories>
      
      <category>大模型应用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大模型</tag>
      
      <tag>RAG</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通过Github仓库异地同步、更新博客文章的方法</title>
    <link href="/2026/01/07/%E9%80%9A%E8%BF%87Github%E4%BB%93%E5%BA%93%E5%BC%82%E5%9C%B0%E5%90%8C%E6%AD%A5%E3%80%81%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <url>/2026/01/07/%E9%80%9A%E8%BF%87Github%E4%BB%93%E5%BA%93%E5%BC%82%E5%9C%B0%E5%90%8C%E6%AD%A5%E3%80%81%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h4 id=""><a href="#" class="headerlink" title=""></a></h4><p>考虑到可能在教研室、宿舍、教室等不同的地方更新博客，就添加了一个github仓库来存储博客的文章内容，这样的话就能够通过这个仓库在不同的工作站上实现同步。思路大致如下：</p><p>由于本站使用hexo建站，实现逻辑是这样的</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">本地Markdown文章 → Hexo生成静态<span class="hljs-selector-tag">HTML</span> → 推送到GitHub Pages → 用户访问<br></code></pre></td></tr></table></figure><p>hexo文档只要绑定到本站对应的page，那么理论在哪里都可以完成Hexo生成静态HTML之后的部分。</p><p>所以想要异地完成的话，其实很简单，只需要同步文件就可以了，这里我通过创建一个github仓库，先通过pull把他们都下载到本地，然后当我更新的时候，把新的markdown文章在push到这个仓库里。</p><p>就能够实现同步了，本质就是把存储这部分放在了github上。</p><p>在任何一个设备上，我想要发一个文章的话，只需要配置基本的git和hexo环境，然后按照下面的流程来就可以：</p><h5 id="1-先同步源码"><a href="#1-先同步源码" class="headerlink" title="1.先同步源码"></a>1.先同步源码</h5><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git pull</span><br></code></pre></td></tr></table></figure><h5 id="2-新建文章"><a href="#2-新建文章" class="headerlink" title="2.新建文章"></a>2.新建文章</h5><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">hexo <span class="hljs-built_in">new</span> <span class="hljs-built_in">post</span> <span class="hljs-string">&quot;文章标题&quot;</span><br></code></pre></td></tr></table></figure><h5 id="3-本地测试"><a href="#3-本地测试" class="headerlink" title="3.本地测试"></a>3.本地测试</h5><figure class="highlight plaintext"><figcaption><span>clean</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs hexo">hexo g<br>hexo s<br></code></pre></td></tr></table></figure><p><code>浏览器打开 http://localhost:4000</code></p><h5 id="4-提交到Github仓库"><a href="#4-提交到Github仓库" class="headerlink" title="4.提交到Github仓库"></a>4.提交到Github仓库</h5><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">git <span class="hljs-keyword">add</span> .<br>git commit -m <span class="hljs-string">&quot;Add post: 文章标题&quot;</span><br>git <span class="hljs-keyword">push</span><br></code></pre></td></tr></table></figure><h5 id="5-在线发布文章"><a href="#5-在线发布文章" class="headerlink" title="5.在线发布文章"></a>5.在线发布文章</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">hexo clean<br>hexo <span class="hljs-selector-tag">g</span><br>hexo d<br></code></pre></td></tr></table></figure><p>​这种方法的缺点也很明显，所有的文章都是开源的，而且在云端存储，长期积累，仓库体积会越来越大，特别是包含图片时。</p><p>​后续会考虑一些更加合适的方法</p>]]></content>
    
    
    <categories>
      
      <category>博客相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>同步</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>教研室测试</title>
    <link href="/2024/11/10/%E8%BF%9C%E7%A8%8B%E6%B5%8B%E8%AF%95/"/>
    <url>/2024/11/10/%E8%BF%9C%E7%A8%8B%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<p>这是我在 <strong>教研室电脑</strong> 写的第一篇测试博客。</p><ul><li>环境：新电脑</li><li>方式：git + hexo</li><li>目标：多地点无缝写博客</li></ul><p>如果能看到这篇文章，说明这条链路是通的 </p>]]></content>
    
    
    <categories>
      
      <category>日志</category>
      
    </categories>
    
    
    <tags>
      
      <tag>教研室</tag>
      
      <tag>测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>测试</title>
    <link href="/2023/12/05/%E6%B5%8B%E8%AF%95/"/>
    <url>/2023/12/05/%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<p>这是我在 2023 年做的一个测试项目，2025 年才整理到博客上。</p><ul><li>技术栈：Python, PyTorch</li><li>主要工作：模型训练 + 实验记录</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/10/09/hello-world/"/>
    <url>/2023/10/09/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
